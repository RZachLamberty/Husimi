################################################################################
################################################################################
##                                                                            ##
##  Parser.py                                                                 ##
##                                                                            ##
##      This is a collection of routines designed to parse the output         ##
##      generated by the infinite cactus DMRG routine designed by Hitesh      ##
##      Changlani.  Any changes to the text immediately before output blocks, ##
##      as well as changes to the number of collumns in said blocks, will     ##
##      need to be accounted for in these routines.                           ##
##                                                                            ##
################################################################################
################################################################################

import scipy
import cPickle as pickle
import pylab
import os


#########################
#                       #
#   Module constants    #
#                       #
#########################

MEASUREMENT_INFO_FILE = 'TrialArrayDic.pkl'




#####################
#                   #
#   Text Parser     #
#                   #
#####################

def FullUpdate( saveIt = True ):
    """
    For every file in TRIAL_INFO_FILES, parse the text file and add it to the
    pickled object MEASUREMENT_INFO_FILE.  If saveIt is true, save all the
    trials we parse.
    """
    x = {}
    trialInfoFiles = TrialInfoFiles()
    for key in trialInfoFiles:
        fileName = trialInfoFiles[key]
        SingleTrialUpdate( x, key, fileName, saveIt )
    
    with open( MEASUREMENT_INFO_FILE, 'wb' ) as f:
        pickle.dump( x, f )


def PartialUpdate( saveIt = True ):
    """
    Perform an update for all of the TrialInfoFiles which *aren't already*
    recorded -- i.e., all the "new" ones.  If saveIt is true, save all the
    trials we parse.
    """
    with open( MEASUREMENT_INFO_FILE, 'rb' ) as f:
        x = pickle.load( f )
    
    trialInfoFiles = TrialInfoFiles()
    for key in trialInfoFiles:
        if key not in x:
            fileName = trialInfoFiles[key]
            SingleTrialUpdate( x, key, fileName, saveIt )
    
    with open( MEASUREMENT_INFO_FILE, 'wb' ) as f:
        pickle.dump( x, f )
        

def SingleTrialUpdate( x, key, fileName, saveIt = True ):
    """
    Just add the parsed info found in fileName to the dictionary x.  If saveIt
    is true, save this single trial.
    """
    try:
        parsedInfo, trialFromFile = ParseIt( fileName, saveIt )
    except SyntaxError:
        raise ValueError, "Syntax error thrown for " + str( fileName )
    if key == trialFromFile:
        x[ key ] = parsedInfo
    else:
        raw_input( 'Trial ' + str(key) + ' may be incorrect' )


def ParseIt( fileName, saveIt = True ):
    """
    Given a file name, return a dictionary with generation keys and measurement
    array values.  If "saveIt" is True, pickled the resulting dictionary in the
    appropriate place
    """
    x = {}
    
    #   If the fileName ends in pickle, this is easy; if not, we have to go and
    #   actually parse the file
    if fileName.endswith( '.pkl' ):
        with open( '../TrialResults/' + fileName, 'rb' ) as f:
            loadVar = pickle.load( f )
            x, trialFromFile = loadVar
    
    else:
        with open( '../' + fileName, 'rb' ) as f:
            fileString = f.read()
        
        #   Check which paradigm ( 0 is the boundary or center node )
        paradigm = paradigmCheck( fileString )
        
        #   Get the trial information
        
        #   Get the spin value
        spinStartIndex = fileString.find( 'Spin on each site  =', 0 ) + 20
        spinEndIndex = fileString.find( '\n', spinStartIndex )
        spinVal = eval( fileString[ spinStartIndex : spinEndIndex ] )
        
        #   Get the Jx, Jz, and D values
        paramStartIndex = fileString.find( 'J_z,J_x,D = ' ) + 12
        paramEndIndex = fileString.find( 'TRACE: Total number of states', paramStartIndex )
        #   I stopped printing some stuff
        if paramEndIndex == -1:
            paramEndIndex = fileString.find( '\n TRACE', paramStartIndex )
        if paramEndIndex == -1:
            paramEndIndex = fileString.find( '\n Number', paramStartIndex )
        if paramEndIndex == -1:
            paramEndIndex = fileString.find( '\n======================================================================================================================', paramStartIndex)
        params = tuple( [eval(v) for v in fileString[ paramStartIndex : paramEndIndex ].split(' ')] )
        trialFromFile = (spinVal, params[1], params[0], params[2])
        
        
        
        measurementBlockIndex = fileString.find( 'measuring', 0 )
        
        #   Loop through looking for measurement blocks
        while measurementBlockIndex != -1:
            endOfBlockIndex = fileString.find( 'Calling', measurementBlockIndex )
            if endOfBlockIndex == -1:
                endOfBlockIndex = fileString.find( '\n\nNow', measurementBlockIndex )
            subBlockString = fileString[ measurementBlockIndex : endOfBlockIndex ]
            
            try:
                UnwrapBlock( x, subBlockString, spinVal, paradigm )
            except NameError:
                print subBlockString
                raw_input( str( trialFromFile ) )
            
            measurementBlockIndex = fileString.find( 'measuring', measurementBlockIndex + 1 )
        
        
        #   Make sure that we have all the desired Sz sectors
        genList = sorted( x.keys() )
        gen0 = genList[0]
        szList = sorted( x[gen0].keys() )
        for gen in genList:
            if sorted( x[gen].keys() ) != szList:
                tossVal = x.pop(gen)
        
        #   Saving it
        if saveIt:
            with open( '../TrialResults/' + fileName + '.pkl', 'wb' ) as f:
                dumpVar = ( x, trialFromFile )
                pickle.dump( dumpVar, f )
        
    return x, trialFromFile


def paradigmCheck( fileString ):
    """
    Half way through printing results, Hitesh changed the convention re: the
    display of the nodes -- 0 being the boundary or the center.  We will return
    a 0 for the first paradigm, 1 for the second, etc.
    """
    #   Original paradigm
    if fileString.count( "(Note in HJC's notation Last(highest) site is center, 0 corresponds to boundary)" ) != 0:
        return 0
    #   Updated paradigm
    elif fileString.count( "(Note in HJC's notation for printing Last(highest) site is boundary, 0 corresponds to center)" ) != 0:
        return 1
    else:
        raise ValueError, "something's amiss!"
        


def UnwrapBlock( x, blockString, S, paradigm ):
    """
    Given a block string of a certain type, unwrap it.
    
    Current measurements are:
        <Sz>
        <Sz^2>
        <Szi Szc>
        <Si+ Sc->
        <Si- Sc+>
        <Si dot Sc>
    """
    sZStringStart = blockString.find('S_z ') + 4
    sZStringEnd = blockString.find(' of the cactus')
    sZ_Sector_Val = eval( blockString[ sZStringStart : sZStringEnd ] )

    genStringStart = blockString.find('generation ') + 11
    genStringEnd = blockString.find('\n(Note')
    genStringVal = eval( blockString[ genStringStart : genStringEnd ] )

    arrayBlockStart = blockString.find('>\n0') + 2
    arrayBlockEnd = blockString.find('\n\n=')
    if arrayBlockEnd == -1:
        arrayBlockEnd = len(blockString)
    arrayBlockString = blockString[ arrayBlockStart : arrayBlockEnd ]

    arrayBlock = arrayBlockString.split('\n')
    arrayBlock = [ row.split(' ') for row in arrayBlock ]
    for row in arrayBlock:
        ok = True
        while ok:
            try:
                row.remove('')
            except ValueError:
                ok = False
    
    arrayBlock = scipy.array( [[eval(el) for el in row] for row in arrayBlock] )
    
    #   Differences depend on paradigm
    if paradigm == 0:
        #   <Szc Szc> = <Szc^2>
        if arrayBlock[-1,3] == 0:
            arrayBlock[-1,3] = arrayBlock[-1,2]
        
        #   <Sc dot Sc> is trivially <S dot S> = S * (S+1)
        if arrayBlock[-1,-1] == 0:
            arrayBlock[-1,-1] = S * (S + 1.)
        
        #   < S_c^+ S_c^- > = < S_c^- S_c^+ > = < S_c dot S_c > - < S_c^z S_c^z >
        if arrayBlock[-1,-2] == 0:
            arrayBlock[-1,-2] = arrayBlock[-1,-1] - arrayBlock[-1,2]
        if arrayBlock[-1,-3] == 0:
            arrayBlock[-1,-3] = arrayBlock[-1,-1] - arrayBlock[-1,2]
        
        #   The nodes are saved in the "wrong" order
        arrayBlock[:,0] = arrayBlock[:,0].max() - arrayBlock[:,0]
        order = arrayBlock[:,0].argsort()
        arrayBlock = arrayBlock[order]
    
    elif paradigm == 1:
        #   Everything's been filled in correclty, now it has the "right" node
        #   display order.  Do nothing!
        pass
    
    #   Add this new array to the supplied dictionary
    if genStringVal not in x:
        x[genStringVal] = {}
    
    x[genStringVal][sZ_Sector_Val] = arrayBlock


def TrialInfoFiles( startString = 't_' ):
    """
    Find all files of the form
        
        t_S_Jx_Jz_d_genGG
    
    in the parent directory, or pickled files of the form
    
        TrialResults/t_S_Jx_Jz_d_genGG.pkl
        
    then return a dictionary of
    
        (S, Jx, Jz, d): fileName
    
    key-value pairs
    """
    fList = [ fileName for fileName in os.listdir('../') if fileName.startswith( startString ) and fileName.count('_gen') != 0 ]
    pklList = [ fileName for fileName in os.listdir('../TrialResults/') if fileName.startswith( startString ) and fileName.count('_gen') != 0 and fileName.endswith('.pkl') ]
    
    retDic = {}
    
    for fileName in pklList:
        trialKey = tuple( [ eval(el) for el in fileName.split('_')[1:-1] ] )
        retDic[trialKey] = fileName
    
    for fileName in fList:
        trialKey = tuple( [ eval(el) for el in fileName.split('_')[1:-1] ] )
        
        if trialKey in retDic:
            print "\tTrial " + str(trialKey) + " may be redundant with a pickled version, or the source file may need to be moved"
        else:
            retDic[trialKey] = fileName
    
    return retDic
                
    


#########################
#                       #
#   Saving routines     #
#                       #
#########################

def SaveParsedInfoToDictionary( params, x ):
    """
    For trial parameters
    
        params = ( S, Jx, Jz, d )
    
    store the parsed dictionary object x into the pickled dictionary
    TrialArrayDic.pkl
    """
    with open( 'TrialArrayDic.pkl', 'rb' ) as f:
        d = pickle.load( f )
    
    d[ tuple(params) ] = x
    
    with open( 'TrialArrayDic.pkl', 'wb' ) as f:
        pickle.dump( d, f )





#############################################
#                                           #
#   Crappy Plotting routines                #
#   (see Plotter.py for real routines )     #
#                                           #
#############################################

def plot(x, minGen, maxGen):
    
    for gen in x:
        if (gen >= minGen) and (gen <= maxGen):
            xg = x[gen]
            
            for sz in xg:
                
                xgs = xg[sz]
                
                XX = xgs[:,0]
                XX = XX.max() - XX
                
                # < Sz >
                pylab.figure(1)
                pylab.plot( XX, xgs[:,1], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Sz')
                
                # < Sz^2 >
                pylab.figure(2)
                pylab.plot( XX, xgs[:,2], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Sz^2')
                
                # < Siz Scz >
                pylab.figure(3)
                pylab.plot( XX, xgs[:,3], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Siz Scz')
                
                # < Si+ Sc- >
                pylab.figure(4)
                pylab.plot( XX, xgs[:,4], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Si+ Sc-')
                
                # < Si- Sc+ >
                pylab.figure(5)
                pylab.plot( XX, xgs[:,5], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Si- Sc+')
                
                # < Si dot Sj >
                pylab.figure(6)
                pylab.plot( XX, xgs[:,6], linewidth = 3, label = 'gen '+str(gen) + ', Sz = ' + str(sz) )
                pylab.legend()
                pylab.title('Si dot Sj')
                

#########################
#                       #
#   Trial Management    #
#                       #
#########################

def KeysInRange(sSet = 1, jxSet = 1, jzSet = 1, dSet = 0):
    """
    Given either a two-element range or a single value for the variable sets,
    return a list of all recorded trials inside the desired parameter ranges
    """
    trialList = sorted( TrialInfoFiles().keys() )
    
    if type( sSet ) == float or type( sSet ) == int:
        s0, s1 = sSet, sSet
    else:
        if len( sSet ) != 2:
            raise ValueError, "Wrong size for the sSet"
        else:
            s0, s1 = sorted( sSet )
    
    if type( jxSet ) == float or type( jxSet ) == int:
        jx0, jx1 = jxSet, jxSet
    else:
        if len( jxSet ) != 2:
            raise ValueError, "Wrong size for the jxSet"
        else:
            jx0, jx1 = sorted( jxSet )
    
    if type( jzSet ) == float or type( jzSet ) == int:
        jz0, jz1 = jzSet, jzSet
    else:
        if len( jzSet ) != 2:
            raise ValueError, "Wrong size for the jzSet"
        else:
            jz0, jz1 = sorted( jzSet )
    
    if type( dSet ) == float or type( dSet ) == int:
        d0, d1 = dSet, dSet
    else:
        if len( dSet ) != 2:
            raise ValueError, "Wrong size for the dSet"
        else:
            d0, d1 = sorted( dSet )
    
    i = 0
    
    while i < len( trialList ):
        trial = trialList[i]
        S, Jx, Jz, D = trial
        
        if ( s0 <= S and S <= s1 ) and ( jx0 <= Jx and Jx <= jx1 ) and ( jz0 <= Jz and Jz <= jz1 ) and ( d0 <= D and D <= d1 ):
            i += 1
        else:
            tossVal = trialList.pop( i )
    
    return trialList
